\documentclass[11pt,a4paper, uplatex]{jsarticle}
%
\usepackage{amsmath,amssymb}
\usepackage{bm}
\usepackage{graphicx}
\usepackage{ascmac}
\usepackage{listings}
\lstset{
    frame=single,
    numbers=left,
    tabsize=2
}
%
\setlength{\textwidth}{\fullwidth}
\setlength{\textheight}{40\baselineskip}
\addtolength{\textheight}{\topskip}
\setlength{\voffset}{-0.2in}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
%
\newcommand{\divergence}{\mathrm{div}\,}  %ダイバージェンス
\newcommand{\grad}{\mathrm{grad}\,}  %グラディエント
\newcommand{\rot}{\mathrm{rot}\,}  %ローテーション
%
\title{プログラミング言語実験・Ｃ言語 第３回課題レポート}
\author{1510151  栁 裕太}
\date{\today}
\begin{document}
\section{課題5}
%
\subsection{サーバーのみ実行時}
%
\subsection{クライアント実行時}
%
\section{課題6}
%
\subsection{common.c}
%
\subsubsection{copy\_table()}
\paragraph{何の処理？}\mbox{}\\
第二引数の配列の任意の値を第一引数の配列へコピーする処理。
\paragraph{配列への処理内容}\mbox{}\\
第二引数の配列のx行y列の値を第一引数の同じ場所へ代入する
\paragraph{機能実現への決め手}\mbox{}\\
for文を2重にネストし、dst\_cards[i][j]=src\_cards[i][j]とすることで実現が可能となった。
%
\subsubsection{clear\_table()}
\paragraph{何の処理？}\mbox{}\\
引数として受け取ったカードテーブルを初期化する。
\paragraph{配列への処理内容}\mbox{}\\
配列のすべての値を0にする。
\paragraph{機能実現への決め手}\mbox{}\\
for文を2重にネストし、cards[i][j]=0とすることで実現が可能となった。
%
\subsubsection{copy\_cards()}
\paragraph{何の処理？}\mbox{}\\
第二引数の配列のカード情報を第一引数の配列へコピーする処理。
\paragraph{配列への処理内容}\mbox{}\\
第二引数の配列のx行y列(x≦5)の値を第一引数の同じ場所へ代入する
\paragraph{機能実現への決め手}\mbox{}\\
基本的にはcopy\_table()と処理内容は同じである。
1点のみ違いがあり、for文でネストする際にiの制限を8ではなく5とすることで、カード情報のみ指定して初期化することが可能となった。
%
\subsubsection{clear\_cards()}
\paragraph{何の処理？}\mbox{}\\
引数で受け取ったカードテーブルのカード情報の部分のみ初期化する。
\paragraph{配列への処理内容}\mbox{}\\
カードテーブルの第5行までに限り(列は任意)、配列の値を0にする。
\paragraph{機能実現への決め手}\mbox{}\\
基本的にはclear\_table()と処理内容は同じである。
1点のみ違いがあり、for文でネストする際にiの制限を8ではなく5とすることで、カード情報のみ指定して初期化することが可能となった。
%
\subsubsection{diff\_cards()}
\paragraph{何の処理？}\mbox{}\\
ゲーム開始前の貧民・大貧民→大富豪・富豪のカード譲渡において、引数で指定された(search\_low\_card()にて指定された貧民・大貧民持ち札で最も強い1-2枚の)カードを貧民・大貧民の持ち札から削除する処理。
\paragraph{配列への処理内容}\mbox{}\\
第一引数の自分の持ち札を表すcards1と、事前にsearch\_low\_card()にて譲渡=削除すべきカードをcards2[x][y]=1とされた配列を第二引数として受け取った。cards1配列において、cards2[x][y]にて1とされた場所を0にする、つまりcards1[x][y]に0を代入すること。
\paragraph{機能実現への決め手}\mbox{}\\
for文を2重にネストすることで2次元配列cards1[][]全体を探索し、if文として1と指定された場所に限り、cards1の同一の行・列部分に0を代入することで実現可能となった。
%
\subsubsection{or\_cards()}
\paragraph{何の処理？}\mbox{}\\
ゲーム開始前の大富豪・富豪→貧民・大貧民のカード譲渡において、引数で指定された(search\_low\_card()にて指定された貧民・大貧民持ち札で最も強い1-2枚の)カードを富豪・大富豪の持ち札へ追加する処理。
\paragraph{配列への処理内容}\mbox{}\\
第一引数の自分の持ち札を表すcards1と、事前にsearch\_low\_card()にて譲渡=削除すべきカードをcards2[x][y]=1とされた配列を第二引数として受け取った。cards1配列において、cards2[x][y]にて1とされた場所を1にする、つまりcards1[x][y]に1を代入すること。
\paragraph{機能実現への決め手}\mbox{}\\
for文を2重にネストすることで2次元配列cards1[][]全体を探索し、if文として1以上に指定された場所に限り、cards1の同一の行・列部分に1を代入することで実現可能となった。
%
\subsubsection{and\_cards()}
\paragraph{何の処理？}\mbox{}\\
第一引数のcards1配列において、cards2においても1として指定された場所以外をすべて0にする処理。
\paragraph{配列への処理内容}\mbox{}\\
cards1[][]において、cards1とcards2が同じ場所の配列の値がともに1である場合に限り、cards1の該当値を1のままとする。両方共1でないのならば、cards1の該当値は0が代入される。
\paragraph{機能実現への決め手}\mbox{}\\
for文を2重にネストすることで2次元配列cards1[][]全体を探索し、if文としてcards1[i][j]とcards2[i][j]がともに1である場合を\&\&で指定し、その場合はcards[j][i]に1を代入し、それ以外の場合はelseとしてcards[j][i]に0を代入することで、実現可能となった。
%
\subsubsection{not\_cards()}
\paragraph{何の処理？}\mbox{}\\
カードの有無を配列の値を0と1とで入れ替えることで反転する処理。
\paragraph{配列への処理内容}\mbox{}\\
配列の任意の場所の値を0⇄1とで反転している。
\paragraph{機能実現への決め手}\mbox{}\\
for文を2重にネストすることで2次元配列cards[][]全体を探索し、cards[j][i]=1ならば0を、0ならば1をcards[j][i]に代入することで、実現可能となった。
%
\subsubsection{get\_field\_state\_from\_field\_cards()}
\paragraph{何の処理？}\mbox{}\\
場に出ているカードの情報から、現在の場の状況を把握する処理。
\paragraph{配列への処理内容}
\subparagraph{初期段階判定}
cards[i][j]が1である場所を捜し、存在しているカードのスートをfield\_statusのsuit[i]に記録する。すべてのスートを調べた(i=4)ならばjをインクリメントし、iを0に戻す。
\subparagraph{階段判定}
cards[i][j]において、cards[i][J+1]も場に出ている=1である場合、階段が発動していると判定し、field\_statusのis\_sequenceに1を代入する。
\subparagraph{枚数組判定}
階段が不成立の場合(field\_status=0)、まず同一数値における別スートのカードの有無を調べ、存在するならば枚数をカウントするcountをインクリメントし、suit[i]に1を代入する。
存在しなければsuit[i]を代入する。
\subparagraph{革命有無判定}
階段が不成立でjが0または14のとき、革命が発動中ならば、field\_statusのorderに14を代入し、力関係が逆転していることを伝える。
革命中でないのならば、orderには0が代入される。jが0でも14でもない時は、jの値がorderに代入される。
\subparagraph{階段処理判定}
階段が成立中の場合、出されたカードの最大値(j)+1セットの枚数(count)が15を超えず、かつcards[i][j+count]が0でない(場に出ている状態である)間、whileとしてcountをインクリメントする。
その後、革命中ならばfield\_statusのorderにはj+count-1を代入し、革命中でなければjをそのまま代入する。
最後に、field\_statusのsuit[i]に1を代入する。
\subparagraph{場カード有無}
上述のコードによって判定されたcountをfield\_statusのquantityに代入し、更にquantityの数値が0でないのならば、field\_statusのis\_no\_cardに0を代入する。
\paragraph{機能実現への決め手}
\subparagraph{初期段階判定}
whileでjを先に固定し、その後iを0から4までインクリメントしている。スートよりも数字の値の方が重要性が高いため、先に固定することでカード位置の正確な探索が可能になった。
\subparagraph{階段判定}
もし場に同じスートで数字が隣接するカードも出ている場合をif-elseで判別することで可能となった。
\subparagraph{枚数組判定}
jの値は変えずに、iのみ0から4までインクリメントしてcards[i][j]の値を調べることにより、同一数値で何枚カードが存在するか調べることが可能になった。
\subparagraph{革命有無判定}
field\_statusにis\_revという革命有無を記す変数が搭載され、その値の有無によってif-elseを分けることにより、可能なものとなった。
\subparagraph{階段処理判定}
先にスートを固定し、隣接するカードがなくなるまでwhile文を回すことにより、セットで出された階段の枚数の判定が可能になった。
また、革命の有無によって次に出すべき階段のセットの判定を変えることにより、正確に次に出すべきカードを判定することが可能になった。
\subparagraph{場カード有無}
countの値をquantityに移植、さらにquantityが0を超えることをif文でキャッチしその場合is\_no\_cardに0を代入することで新場なのか否かを判別できるようになった。
%
\subsubsection{get\_field\_state\_from\_own\_cards()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsubsection{remove\_low\_card()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsubsection{remove\_suit()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsubsection{count\_cards()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsection{select\_cards.c}
%
\subsubsection{select\_change\_cards()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsubsection{select\_submit\_cards()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsubsection{select\_cards\_restrict()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\
%
\subsubsection{select\_cards\_free()}
\paragraph{何の処理？}\mbox{}\\
\paragraph{配列への処理内容}\mbox{}\\
\paragraph{機能実現への決め手}\mbox{}\\

\end{document}
